// server.js - –£–õ–£–ß–®–ï–ù–ù–´–ô Backend v6 (–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –∏ –ª–æ–≥ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏)
const express = require('express');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const axios = require('axios');
const { Pool } = require('pg');

const app = express();

app.use(cors());
app.use(express.json({ limit: '10mb' }));

const PORT = process.env.PORT || 3000;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-this';
const TWITCH_CLIENT_ID = process.env.TWITCH_CLIENT_ID;
const TWITCH_CLIENT_SECRET = process.env.TWITCH_CLIENT_SECRET;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

let twitchAccessToken = null;
let tokenExpiry = null;

async function initDatabase() {
  const client = await pool.connect();
  try {
    await client.query(`
      CREATE TABLE IF NOT EXISTS users (
        id SERIAL PRIMARY KEY,
        username VARCHAR(50) UNIQUE NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        password VARCHAR(255) NOT NULL,
        avatar TEXT,
        bio TEXT,
        theme VARCHAR(20) DEFAULT 'default',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS games (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        game_id BIGINT NOT NULL,
        name VARCHAR(255) NOT NULL,
        cover TEXT,
        board VARCHAR(20) NOT NULL,
        position INTEGER DEFAULT 0,
        rating INTEGER CHECK (rating >= 1 AND rating <= 5),
        notes TEXT,
        hours_played INTEGER DEFAULT 0,
        added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );

      CREATE TABLE IF NOT EXISTS friendships (
        id SERIAL PRIMARY KEY,
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        friend_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        status VARCHAR(20) DEFAULT 'pending',
        nickname VARCHAR(100),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(user_id, friend_id)
      );

      CREATE TABLE IF NOT EXISTS reactions (
        id SERIAL PRIMARY KEY,
        game_id INTEGER REFERENCES games(id) ON DELETE CASCADE,
        user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
        emoji VARCHAR(10) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE(game_id, user_id)
      );
      
      CREATE TABLE IF NOT EXISTS activity_log (
          id SERIAL PRIMARY KEY,
          user_id INTEGER REFERENCES users(id) ON DELETE CASCADE NOT NULL,
          action_type VARCHAR(50) NOT NULL,
          details JSONB,
          created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
      );

      CREATE INDEX IF NOT EXISTS idx_games_user_id ON games(user_id);
      CREATE INDEX IF NOT EXISTS idx_friendships_user_id ON friendships(user_id);
      CREATE INDEX IF NOT EXISTS idx_reactions_game_id ON reactions(game_id);
      CREATE INDEX IF NOT EXISTS idx_activity_log_user_id ON activity_log(user_id);

      ALTER TABLE games ADD COLUMN IF NOT EXISTS position INTEGER DEFAULT 0;
    `);
    console.log('‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞');
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î:', error);
  } finally {
    client.release();
  }
}

initDatabase();

// Helper to log activities
const logActivity = async (userId, actionType, details) => {
    const client = await pool.connect();
    try {
        await client.query(
            'INSERT INTO activity_log (user_id, action_type, details) VALUES ($1, $2, $3)',
            [userId, actionType, details]
        );
    } catch (err) {
        console.error("–û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è:", err);
    } finally {
        client.release();
    }
};


async function getTwitchToken() {
  if (twitchAccessToken && tokenExpiry && Date.now() < tokenExpiry) {
    return twitchAccessToken;
  }
  try {
    const response = await axios.post('https://id.twitch.tv/oauth2/token', null, {
      params: {
        client_id: TWITCH_CLIENT_ID,
        client_secret: TWITCH_CLIENT_SECRET,
        grant_type: 'client_credentials'
      }
    });
    twitchAccessToken = response.data.access_token;
    tokenExpiry = Date.now() + (response.data.expires_in * 1000);
    return twitchAccessToken;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ Twitch —Ç–æ–∫–µ–Ω–∞:', error.message);
    throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ Twitch API');
  }
}

function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  if (!token) return res.status(401).json({ error: '–¢—Ä–µ–±—É–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è' });
  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ error: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' });
    req.user = user;
    next();
  });
}

// === AUTH ===

app.post('/api/auth/register', async (req, res) => {
  const client = await pool.connect();
  try {
    const { username, email, password } = req.body;
    if (!username || !email || !password) {
      return res.status(400).json({ error: '–í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' });
    }
    if (password.length < 6) {
      return res.status(400).json({ error: '–ü–∞—Ä–æ–ª—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤' });
    }

    const hashedPassword = await bcrypt.hash(password, 10);
    const result = await client.query(
      'INSERT INTO users (username, email, password) VALUES ($1, $2, $3) RETURNING id, username, email, avatar, bio, theme',
      [username, email, hashedPassword]
    );

    const user = result.rows[0];
    const token = jwt.sign({ id: user.id, username: user.username }, JWT_SECRET, { expiresIn: '30d' });

    res.status(201).json({
      message: '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞',
      token,
      user
    });
  } catch (error) {
    if (error.code === '23505') {
      return res.status(400).json({ error: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–ª–∏ email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' });
    }
    console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.post('/api/auth/login', async (req, res) => {
  const client = await pool.connect();
  try {
    const { username, password } = req.body;
    const result = await client.query('SELECT * FROM users WHERE username = $1', [username]);
    if (result.rows.length === 0) {
      return res.status(401).json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–µ —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' });
    }

    const user = result.rows[0];
    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(401).json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–µ —É—á–µ—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' });
    }

    const token = jwt.sign({ id: user.id, username: user.username }, JWT_SECRET, { expiresIn: '30d' });

    res.json({
      message: '–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω',
      token,
      user: { id: user.id, username: user.username, email: user.email, avatar: user.avatar, bio: user.bio, theme: user.theme }
    });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

// === PROFILE ===

app.get('/api/profile', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const result = await client.query(
      'SELECT id, username, email, avatar, bio, theme, created_at FROM users WHERE id = $1',
      [req.user.id]
    );
    res.json({ user: result.rows[0] });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.post('/api/profile/avatar', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { avatar } = req.body;
    
    if (!avatar || !avatar.startsWith('data:image/')) {
      return res.status(400).json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è' });
    }

    const result = await client.query(
      'UPDATE users SET avatar = $1 WHERE id = $2 RETURNING *',
      [avatar, req.user.id]
    );

    const user = result.rows[0];

    res.json({ message: '–ê–≤–∞—Ç–∞—Ä –æ–±–Ω–æ–≤–ª–µ–Ω', user: { id: user.id, username: user.username, email: user.email, avatar: user.avatar, bio: user.bio, theme: user.theme } });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞–≤–∞—Ç–∞—Ä–∞:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∞–≤–∞—Ç–∞—Ä–∞' });
  } finally {
    client.release();
  }
});

app.put('/api/profile', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { username, bio, theme, currentPassword, newPassword } = req.body;
    
    let updateFields = [];
    let values = [];
    let paramCount = 1;

    if (username) {
      updateFields.push(`username = $${paramCount++}`);
      values.push(username);
    }
    if (bio !== undefined) {
      updateFields.push(`bio = $${paramCount++}`);
      values.push(bio);
    }
    if (theme) {
        updateFields.push(`theme = $${paramCount++}`);
        values.push(theme);
    }
    if (newPassword) {
      if (!currentPassword) {
        return res.status(400).json({ error: '–¢—Ä–µ–±—É–µ—Ç—Å—è —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å' });
      }
      const userResult = await client.query('SELECT password FROM users WHERE id = $1', [req.user.id]);
      const validPassword = await bcrypt.compare(currentPassword, userResult.rows[0].password);
      if (!validPassword) {
        return res.status(401).json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–π —Ç–µ–∫—É—â–∏–π –ø–∞—Ä–æ–ª—å' });
      }
      const hashedPassword = await bcrypt.hash(newPassword, 10);
      updateFields.push(`password = $${paramCount++}`);
      values.push(hashedPassword);
    }

    if (updateFields.length === 0) {
      return res.status(400).json({ error: '–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è' });
    }

    values.push(req.user.id);
    const result = await client.query(
      `UPDATE users SET ${updateFields.join(', ')} WHERE id = $${paramCount} RETURNING *`,
      values
    );

    const updatedUser = result.rows[0];
    const newToken = jwt.sign({ id: updatedUser.id, username: updatedUser.username }, JWT_SECRET, { expiresIn: '30d' });

    res.json({ 
        message: '–ü—Ä–æ—Ñ–∏–ª—å –æ–±–Ω–æ–≤–ª–µ–Ω', 
        user: { id: updatedUser.id, username: updatedUser.username, email: updatedUser.email, avatar: updatedUser.avatar, bio: updatedUser.bio, theme: updatedUser.theme }, 
        token: newToken 
    });
  } catch (error) {
    if (error.code === '23505') {
      return res.status(400).json({ error: '–≠—Ç–æ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É–∂–µ –∑–∞–Ω—è—Ç–æ' });
    }
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});


// === GAMES ===

app.get('/api/games/search', authenticateToken, async (req, res) => {
  try {
    const { q } = req.query;
    if (!q || q.length < 2) {
      return res.status(400).json({ error: '–ú–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞' });
    }

    const token = await getTwitchToken();
    const response = await axios.post(
      'https://api.igdb.com/v4/games',
      `search "${q}"; fields name, cover.url, summary, rating, genres.name; limit 20;`,
      {
        headers: {
          'Client-ID': TWITCH_CLIENT_ID,
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'text/plain'
        }
      }
    );

    const games = response.data.map(game => ({
      id: game.id,
      name: game.name,
      cover: game.cover?.url ? `https:${game.cover.url.replace('t_thumb', 't_cover_big')}` : null,
      summary: game.summary || '',
      rating: game.rating ? Math.round(game.rating / 20) : null,
      genres: game.genres?.map(g => g.name) || []
    }));

    res.json({ games });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞:', error.message);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞' });
  }
});

app.get('/api/user/boards', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const result = await client.query(
      `SELECT g.*, 
        COALESCE(json_agg(
          json_build_object('user_id', r.user_id, 'emoji', r.emoji, 'username', u.username, 'avatar', u.avatar)
        ) FILTER (WHERE r.id IS NOT NULL), '[]') as reactions
       FROM games g
       LEFT JOIN reactions r ON g.id = r.game_id
       LEFT JOIN users u ON r.user_id = u.id
       WHERE g.user_id = $1
       GROUP BY g.id
       ORDER BY g.position ASC, g.added_at DESC`,
      [req.user.id]
    );

    const boards = { backlog: [], playing: [], completed: [], dropped: [] };

    result.rows.forEach(game => {
      const card = {
        id: game.id.toString(),
        gameId: game.game_id,
        name: game.name,
        cover: game.cover,
        rating: game.rating,
        notes: game.notes,
        hoursPlayed: game.hours_played,
        addedDate: game.added_at,
        reactions: game.reactions
      };
      if (boards[game.board]) {
        boards[game.board].push(card);
      }
    });

    res.json({ boards });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ—Å–æ–∫:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.post('/api/user/boards/:boardId/games', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { boardId } = req.params;
    const { game } = req.body;

    if (!game || !game.id || !game.name) {
      return res.status(400).json({ error: '–ù–µ–ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–≥—Ä—ã' });
    }

    const result = await client.query(
      'INSERT INTO games (user_id, game_id, name, cover, board) VALUES ($1, $2, $3, $4, $5) RETURNING *',
      [req.user.id, game.id, game.name, game.cover || null, boardId]
    );
    
    logActivity(req.user.id, 'add_game', { gameName: game.name, board: boardId });

    res.status(201).json({ message: '–ò–≥—Ä–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞', game: result.rows[0] });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∏–≥—Ä—ã:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞', details: error.message });
  } finally {
    client.release();
  }
});

app.delete('/api/user/games/:gameId', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { gameId } = req.params;
    const gameResult = await client.query('SELECT name FROM games WHERE id = $1 AND user_id = $2', [gameId, req.user.id]);
    if (gameResult.rows.length > 0) {
        logActivity(req.user.id, 'remove_game', { gameName: gameResult.rows[0].name });
    }
    await client.query('DELETE FROM games WHERE id = $1 AND user_id = $2', [gameId, req.user.id]);
    res.json({ message: '–ò–≥—Ä–∞ —É–¥–∞–ª–µ–Ω–∞' });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.put('/api/user/games/:gameId', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { gameId } = req.params;
    const { board, rating, notes, hoursPlayed } = req.body;
    
    const oldGameResult = await client.query('SELECT * FROM games WHERE id = $1 AND user_id = $2', [gameId, req.user.id]);
    if(oldGameResult.rows.length === 0) {
        return res.status(404).json({ error: '–ò–≥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞'});
    }
    const oldGame = oldGameResult.rows[0];

    let updateFields = [];
    let values = [];
    let paramCount = 1;

    if (board) { updateFields.push(`board = $${paramCount++}`); values.push(board); }
    if (rating !== undefined) { updateFields.push(`rating = $${paramCount++}`); values.push(rating); }
    if (notes !== undefined) { updateFields.push(`notes = $${paramCount++}`); values.push(notes); }
    if (hoursPlayed !== undefined) { updateFields.push(`hours_played = $${paramCount++}`); values.push(hoursPlayed); }
    updateFields.push(`updated_at = CURRENT_TIMESTAMP`);
    values.push(gameId, req.user.id);

    const result = await client.query(
      `UPDATE games SET ${updateFields.join(', ')} WHERE id = $${paramCount} AND user_id = $${paramCount + 1} RETURNING *`,
      values
    );
    
    if (board && oldGame.board !== board) {
        if (board === 'completed') {
            logActivity(req.user.id, 'complete_game', { gameName: oldGame.name });
        } else {
            logActivity(req.user.id, 'move_game', { gameName: oldGame.name, fromBoard: oldGame.board, toBoard: board });
        }
    }

    res.json({ message: '–ò–≥—Ä–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞', game: result.rows[0] });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.put('/api/user/boards/reorder', authenticateToken, async (req, res) => {
    const { boardId, orderedIds } = req.body;
    if (!boardId || !Array.isArray(orderedIds)) {
        return res.status(400).json({ error: '–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã'});
    }
    const client = await pool.connect();
    try {
        await client.query('BEGIN');
        for (let i = 0; i < orderedIds.length; i++) {
            const gameId = orderedIds[i];
            const position = i;
            await client.query(
                'UPDATE games SET position = $1 WHERE id = $2 AND user_id = $3 AND board = $4',
                [position, gameId, req.user.id, boardId]
            );
        }
        await client.query('COMMIT');
        res.json({ message: '–ü–æ—Ä—è–¥–æ–∫ –æ–±–Ω–æ–≤–ª–µ–Ω' });
    } catch (error) {
        await client.query('ROLLBACK');
        console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Ä—è–¥–∫–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    } finally {
        client.release();
    }
});


// === REACTIONS ===

app.post('/api/games/:gameId/reactions', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { gameId } = req.params;
    const { emoji } = req.body;

    await client.query(
      'INSERT INTO reactions (game_id, user_id, emoji) VALUES ($1, $2, $3) ON CONFLICT (game_id, user_id) DO UPDATE SET emoji = $3',
      [gameId, req.user.id, emoji]
    );

    res.json({ message: '–†–µ–∞–∫—Ü–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞' });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Ä–µ–∞–∫—Ü–∏–∏:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

// === USERS & FRIENDS ===

app.get('/api/users', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { q } = req.query;
    let query, params;
    
    if (q) {
      query = 'SELECT id, username, avatar, bio FROM users WHERE username ILIKE $1 AND id != $2 LIMIT 50';
      params = [`%${q}%`, req.user.id];
    } else {
      query = 'SELECT id, username, avatar, bio FROM users WHERE id != $1 ORDER BY created_at DESC LIMIT 100';
      params = [req.user.id];
    }
    
    const result = await client.query(query, params);
    res.json({ users: result.rows });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.post('/api/friends/request', authenticateToken, async (req, res) => {
    const client = await pool.connect();
    try {
        const { friendId } = req.body;
        if (req.user.id == friendId) {
            return res.status(400).json({ error: '–ù–µ–ª—å–∑—è –¥–æ–±–∞–≤–∏—Ç—å —Å–µ–±—è –≤ –¥—Ä—É–∑—å—è' });
        }
        await client.query(
            "INSERT INTO friendships (user_id, friend_id, status) VALUES ($1, $2, 'pending') ON CONFLICT (user_id, friend_id) DO NOTHING",
            [req.user.id, friendId]
        );
        res.json({ message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω' });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    } finally {
        client.release();
    }
});

app.post('/api/friends/accept', authenticateToken, async (req, res) => {
    const client = await pool.connect();
    try {
        const { friendId } = req.body;
        await client.query(
            "UPDATE friendships SET status = 'accepted' WHERE user_id = $1 AND friend_id = $2 AND status = 'pending'",
            [friendId, req.user.id]
        );
        await client.query(
            "INSERT INTO friendships (user_id, friend_id, status) VALUES ($1, $2, 'accepted') ON CONFLICT (user_id, friend_id) DO UPDATE SET status = 'accepted'",
            [req.user.id, friendId]
        );
        res.json({ message: '–î—Ä—É–≥ –¥–æ–±–∞–≤–ª–µ–Ω' });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è –∑–∞–ø—Ä–æ—Å–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    } finally {
        client.release();
    }
});

app.post('/api/friends/reject', authenticateToken, async (req, res) => {
    const client = await pool.connect();
    try {
        const { friendId } = req.body;
        await client.query(
            'DELETE FROM friendships WHERE (user_id = $1 AND friend_id = $2) OR (user_id = $2 AND friend_id = $1)',
            [req.user.id, friendId]
        );
        res.json({ message: '–ó–∞–ø—Ä–æ—Å –æ—Ç–∫–ª–æ–Ω–µ–Ω' });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –∑–∞–ø—Ä–æ—Å–∞:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    } finally {
        client.release();
    }
});

app.put('/api/friends/:friendId/nickname', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { friendId } = req.params;
    const { nickname } = req.body;
    
    await client.query(
      'UPDATE friendships SET nickname = $1 WHERE user_id = $2 AND friend_id = $3',
      [nickname, req.user.id, friendId]
    );
    
    res.json({ message: '–ú–µ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞' });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –º–µ—Ç–∫–∏:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.delete('/api/friends/:friendId', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { friendId } = req.params;
    await client.query('DELETE FROM friendships WHERE (user_id = $1 AND friend_id = $2) OR (user_id = $2 AND friend_id = $1)', [req.user.id, friendId]);
    res.json({ message: '–î—Ä—É–≥ —É–¥–∞–ª–µ–Ω' });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –¥—Ä—É–≥–∞:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.get('/api/friends', authenticateToken, async (req, res) => {
    const client = await pool.connect();
    try {
        const friendsResult = await client.query(
            `SELECT u.id, u.username, u.avatar, u.bio, f.nickname
             FROM friendships f JOIN users u ON f.friend_id = u.id
             WHERE f.user_id = $1 AND f.status = 'accepted'`, [req.user.id]
        );
        const requestsResult = await client.query(
            `SELECT u.id, u.username, u.avatar, u.bio
             FROM friendships f JOIN users u ON f.user_id = u.id
             WHERE f.friend_id = $1 AND f.status = 'pending'`, [req.user.id]
        );
        const sentRequestsResult = await client.query(
            `SELECT f.friend_id as id
             FROM friendships f
             WHERE f.user_id = $1 AND f.status = 'pending'`, [req.user.id]
        );

        res.json({
            friends: friendsResult.rows,
            requests: requestsResult.rows,
            sentRequests: sentRequestsResult.rows.map(r => r.id)
        });
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥—Ä—É–∑–µ–π –∏ –∑–∞–ø—Ä–æ—Å–æ–≤:', error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    } finally {
        client.release();
    }
});

app.get('/api/friends/activity', authenticateToken, async(req, res) => {
    const client = await pool.connect();
    try {
        const result = await client.query(
            `SELECT al.id, al.action_type, al.details, al.created_at, u.username 
             FROM activity_log al 
             JOIN users u ON al.user_id = u.id
             WHERE al.user_id IN (SELECT friend_id FROM friendships WHERE user_id = $1 AND status = 'accepted')
             ORDER BY al.created_at DESC
             LIMIT 50`,
             [req.user.id]
        );
        res.json({ activities: result.rows });
    } catch(error) {
        console.error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:", error);
        res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    } finally {
        client.release();
    }
});


app.get('/api/user/:userId/boards', authenticateToken, async (req, res) => {
  const client = await pool.connect();
  try {
    const { userId } = req.params;
    const result = await client.query(
      `SELECT g.*, u.username, u.avatar,
        COALESCE(json_agg(
          json_build_object('user_id', r.user_id, 'emoji', r.emoji, 'username', ru.username, 'avatar', ru.avatar)
        ) FILTER (WHERE r.id IS NOT NULL), '[]') as reactions
       FROM games g
       JOIN users u ON g.user_id = u.id
       LEFT JOIN reactions r ON g.id = r.game_id
       LEFT JOIN users ru ON r.user_id = ru.id
       WHERE g.user_id = $1
       GROUP BY g.id, u.username, u.avatar
       ORDER BY g.position ASC, g.added_at DESC`,
      [userId]
    );

    const boards = { backlog: [], playing: [], completed: [], dropped: [] };
    result.rows.forEach(game => {
      const card = {
        id: game.id.toString(),
        gameId: game.game_id,
        name: game.name,
        cover: game.cover,
        rating: game.rating,
        notes: game.notes,
        hoursPlayed: game.hours_played,
        addedDate: game.added_at,
        reactions: game.reactions,
        owner: { username: game.username, avatar: game.avatar }
      };
      if (boards[game.board]) boards[game.board].push(card);
    });

    const userInfo = await client.query('SELECT id, username, avatar, bio, theme FROM users WHERE id = $1', [userId]);
    
    let friendship = 'none';
    let nickname = null;

    if (req.user.id != userId) {
        const friendshipStatusQuery = await client.query(
          `SELECT status, user_id, (SELECT nickname FROM friendships WHERE user_id = $1 AND friend_id = $2) as nickname 
           FROM friendships 
           WHERE (user_id = $1 AND friend_id = $2) OR (user_id = $2 AND friend_id = $1)`,
          [req.user.id, userId]
        );
        
        if (friendshipStatusQuery.rows.length > 0) {
            const f_status = friendshipStatusQuery.rows[0];
            nickname = f_status.nickname;
            if (f_status.status === 'accepted') {
                friendship = 'friends';
            } else if (f_status.status === 'pending') {
                friendship = (f_status.user_id == req.user.id) ? 'request_sent' : 'request_received';
            }
        }
    }

    res.json({ boards, user: userInfo.rows[0], friendship, nickname });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–æ—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    res.status(500).json({ error: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
  } finally {
    client.release();
  }
});

app.listen(PORT, () => {
  console.log(`üöÄ –°–µ—Ä–≤–µ—Ä –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`);
});
